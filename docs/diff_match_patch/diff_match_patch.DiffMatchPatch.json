{"name":"DiffMatchPatch","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch","comment":"<p>Class containing the diff, match and patch methods.\nAlso contains the behaviour settings.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"diffEditCost":{"name":"diffEditCost","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diffEditCost","comment":"<p>Cost of an empty edit operation in terms of edit characters.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"diffTimeout":{"name":"diffTimeout","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diffTimeout","comment":"<p>Number of seconds to map a diff before giving up (0 for infinity).</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"matchDistance":{"name":"matchDistance","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.matchDistance","comment":"<p>How far to search for a match (0 = exact location, 1000+ = broad match).\nA match this many characters away from the expected location will add\n1.0 to the score (0.0 is a perfect match).</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"matchThreshold":{"name":"matchThreshold","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.matchThreshold","comment":"<p>At what point is no match declared (0.0 = perfection, 1.0 = very loose).</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"patchDeleteThreshold":{"name":"patchDeleteThreshold","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.patchDeleteThreshold","comment":"<p>When deleting a large block of text (over ~64 characters), how close do\nthe contents have to be to match the expected contents. (0.0 = perfection,\n1.0 = very loose).  Note that Match_Threshold controls how closely the\nend points of a delete need to match.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"patchMargin":{"name":"patchMargin","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.patchMargin","comment":"<p>Chunk size for context length.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"diff":{"name":"diff","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diff","comment":"<p>Find the differences between two texts.  Simplifies the problem by\nstripping any common prefix or suffix off the texts before diffing.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diff.text1</a> is the old string to be diffed.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diff.text2</a> is the new string to be diffed.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diff.checklines</a> is an optional speedup flag.  If present and false, then don't</p>\n<pre><code>run a line-level diff first to identify the changed areas.\nDefaults to true, which does a faster, slightly less optimal diff.\n</code></pre>\n<p><a>diff_match_patch/diff_match_patch.DiffMatchPatch.diff.deadline</a> is an optional time when the diff should be complete by.  Used</p>\n<pre><code>internally for recursive calls.  Users should set DiffTimeout instead.\n</code></pre>\n<p>Returns a List of Diff objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Diff","inner":[]}]}],"parameters":{"text1":{"name":"text1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"text2":{"name":"text2","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"checklines":{"name":"checklines","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"deadline":{"name":"deadline","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"diffCleanupEfficiency":{"name":"diffCleanupEfficiency","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diffCleanupEfficiency","comment":"<p>Reduce the number of edits by eliminating operationally trivial equalities.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diffCleanupEfficiency.diffs</a> is a List of Diff objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"diffs":{"name":"diffs","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Diff","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"diffCleanupSemantic":{"name":"diffCleanupSemantic","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diffCleanupSemantic","comment":"<p>Reduce the number of edits by eliminating semantically trivial equalities.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diffCleanupSemantic.diffs</a> is a List of Diff objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"diffs":{"name":"diffs","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Diff","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"diff_levenshtein":{"name":"diff_levenshtein","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.diff_levenshtein","comment":"<p>Compute the Levenshtein distance; the number of inserted, deleted or\nsubstituted characters.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.diff_levenshtein.diffs</a> is a List of Diff objects.\nReturns the number of changes.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"diffs":{"name":"diffs","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Diff","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"match":{"name":"match","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.match","comment":"<p>Locate the best instance of 'pattern' in 'text' near 'loc'.\nReturns -1 if no match found.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.match.text</a> is the text to search.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.match.pattern</a> is the pattern to search for.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.match.loc</a> is the location to search around.\nReturns the best match index or -1.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"loc":{"name":"loc","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"patch":{"name":"patch","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.patch","comment":"<p>Compute a list of patches to turn text1 into text2.\nUse diffs if provided, otherwise compute it ourselves.\nThere are four ways to call this function, depending on what data is\navailable to the caller:\nMethod 1:\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.a</a> = text1, <a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.opt_b</a> = text2\nMethod 2:\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.a</a> = diffs\nMethod 3 (optimal):\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.a</a> = text1, <a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.opt_b</a> = diffs\nMethod 4 (deprecated, use method 3):\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.a</a> = text1, <a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.opt_b</a> = text2, <a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch.opt_c</a> = diffs\nReturns a List of Patch objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Patch","inner":[]}]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"opt_b":{"name":"opt_b","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"opt_c":{"name":"opt_c","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"patch_apply":{"name":"patch_apply","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.patch_apply","comment":"<p>Merge a set of patches onto the text.  Return a patched text, as well\nas an array of true/false values indicating which patches were applied.\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch_apply.patches</a> is a List of Patch objects\n<a>diff_match_patch/diff_match_patch.DiffMatchPatch.patch_apply.text</a> is the old text.\nReturns a two element List, containing the new text and a List of</p>\n<pre><code> bool values.\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[]}],"parameters":{"patches":{"name":"patches","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"diff_match_patch/diff_match_patch.Patch","inner":[]}]}],"value":null,"annotations":[]},"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>diff_match_patch/diff_match_patch.DiffMatchPatch.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>diff_match_patch/diff_match_patch.DiffMatchPatch.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>diff_match_patch/diff_match_patch.DiffMatchPatch.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.noSuchMethod","comment":"<p><a>diff_match_patch/diff_match_patch.DiffMatchPatch.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>diff_match_patch/diff_match_patch.DiffMatchPatch.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>diff_match_patch/diff_match_patch.DiffMatchPatch.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>diff_match_patch/diff_match_patch.DiffMatchPatch.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"diff_match_patch/diff_match_patch.DiffMatchPatch.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}